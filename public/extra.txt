<!-- public/settings.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <!-- ... existing head elements ... -->
    <link rel="stylesheet" href="css/styles.css">
    <title>Settings - Study Timer</title>
</head>
<body>
    <header>
        <nav>
            <ul>
                <li><a href="index.html">Timer</a></li>
                <li><a href="stats.html">Stats</a></li>
                <li><a href="settings.html" class="active">Settings</a></li>
            </ul>
        </nav>
    </header>
    <div class="main-content">
        <h1>Settings</h1>
        <form id="settings-form">
            <!-- Work Duration Slider -->
            <label for="work-duration-slider">Work Duration (minutes):</label>
            <div>
                <input type="range" id="work-duration-slider" name="work-duration" min="5" max="60" value="25" step="1">
                <span id="work-duration-value">25</span> min
            </div>
            <br>

            <!-- Short Break Slider -->
            <label for="short-break-slider">Short Break (minutes):</label>
            <div>
                <input type="range" id="short-break-slider" name="short-break" min="1" max="30" value="5" step="1">
                <span id="short-break-value">5</span> min
            </div>
            <br>

            <!-- Long Break Slider -->
            <label for="long-break-slider">Long Break (minutes):</label>
            <div>
                <input type="range" id="long-break-slider" name="long-break" min="1" max="60" value="15" step="1">
                <span id="long-break-value">15</span> min
            </div>
            <br>

            <!-- Number of Sessions Slider -->
            <label for="sessions-slider">Number of Sessions before Long Break:</label>
            <div>
                <input type="range" id="sessions-slider" name="sessions" min="1" max="10" value="4" step="1">
                <span id="sessions-value">4</span>
            </div>
            <br>

            <!-- New single Autostart checkbox -->
            <label for="auto-start-all">Autostart (Timer & Breaks):</label>
            <input type="checkbox" id="auto-start-all" name="auto-start-all">
            <br><br>

            <button type="submit">Save Settings</button>
            <button type="button" id="reset-default-btn">Reset to Original Defaults</button>
        </form>
    </div>
    <script src="js/defaultSettings.js" type="module"></script>
    <script src="js/settings.js" type="module"></script>
</body>
</html>


// In settings.js, after DOMContentLoaded:
document.getElementById('settings-btn').addEventListener('click', async () => {
    document.getElementById('settings-modal').classList.remove('hidden');
    await loadSettingsBasedOnLogin();
  });
  document.getElementById('close-settings').addEventListener('click', () => {
    document.getElementById('settings-modal').classList.add('hidden');
  });
  
// at the end of settings.js
window.loadSettingsBasedOnLogin = loadSettingsBasedOnLogin;

/*
    const updateDisplayValue = (slider, display) => {
        display.textContent = slider.value;
    };
    */


------------------------------------------

// public/js/timer.js

// Global Variables
let startTime = 25 * 60; // Default timer duration in seconds (25 minutes)
let currentTime = startTime; // Tracks the remaining time in the current session
let timerInterval = null; // Holds the reference to the interval timer
let isRunning = false; // Boolean to track whether the timer is running
let currentSession = 'Timer'; // Tracks the current session type: 'Timer', 'Short Break', or 'Long Break'
let sessionCount = 1; // Tracks the number of completed work sessions
let sessionsBeforeLongBreak = 4; // Default number of work sessions before a long break

// Variables to hold auto-start settings
// Single auto-start setting
let autoStartAll = false;

// Variables to hold break durations
let shortBreakDuration = 5 * 60; // default 5 minutes
let longBreakDuration = 15 * 60; // default 15 minutes

// Load settings and attach event listeners
document.addEventListener('DOMContentLoaded', function () {
    loadSettings(); // Load settings on start
    attachEventListeners(); // Attach event listeners to UI elements
});

// Attach event listeners to buttons
function attachEventListeners() {
    // Event listener for start/pause button
    document.getElementById('start-pause-btn').addEventListener('click', toggleTimer);
    // Event listener for reset button
    document.getElementById('reset-btn').addEventListener('click', resetTimer);
    // Event listener for skip button
    document.getElementById('skip-btn').addEventListener('click', skipToBreak);
}

// Function to check if user is logged in
async function isLoggedIn() {
    try {
        const res = await fetch('/check-session', { method: 'GET', credentials: 'include' });
        if (!res.ok) throw new Error('Failed to check session');
        const data = await res.json();
        return data.loggedIn;
    } catch (err) {
        console.error('Error checking session:', err);
        return false;
    }
}

// Function to load settings from server
async function loadSettingsFromServer() {
    try {
        const res = await fetch('/settings', { method: 'GET', credentials: 'include' });
        if (!res.ok) throw new Error('Failed to fetch settings');
        const settings = await res.json();
        // Set global variables based on settings
        startTime = settings.workDuration * 60;
        currentTime = startTime;
        sessionsBeforeLongBreak = settings.sessionsBeforeLongBreak;
        autoStartAll = settings.autoStartAll;

        shortBreakDuration = settings.shortBreak * 60;
        longBreakDuration = settings.longBreak * 60;

        updateDisplay(); // Update the timer display

        // Do not auto-start on page load
    } catch (err) {
        console.error('Error loading settings from server:', err);
        loadDefaultSettings();
    }
}

// Function to load default settings
function loadDefaultSettings() {
    // Set default settings
    startTime = 25 * 60;
    currentTime = startTime;
    sessionsBeforeLongBreak = 4;
    autoStartAll = false;

    shortBreakDuration = 5 * 60;
    longBreakDuration = 15 * 60;

    updateDisplay(); // Update the timer display

    // Do not auto-start on page load
}

// Function to load settings from localStorage
function loadSettingsFromLocalStorage() {
    // Load settings from localStorage or use defaults
    const settings = JSON.parse(localStorage.getItem('settings')) || {
        workDuration: 25,
        shortBreak: 5,
        longBreak: 15,
        sessionsBeforeLongBreak: 4,
        autoStartAll: false,
    };

    startTime = settings.workDuration * 60;
    currentTime = startTime;
    sessionsBeforeLongBreak = settings.sessionsBeforeLongBreak;
    autoStartAll = settings.autoStartAll;

    shortBreakDuration = settings.shortBreak * 60;
    longBreakDuration = settings.longBreak * 60;

    updateDisplay(); // Update the timer display
}

// Function to load settings based on login status
async function loadSettings() {
    const loggedIn = await isLoggedIn();
    if (loggedIn) {
        await loadSettingsFromServer();
    } else {
        loadSettingsFromLocalStorage();
    }
}

// Toggle timer between running and paused states
function toggleTimer() {
    if (!isRunning) {
        startTimer(); // Start the timer if not running
    } else {
        pauseTimer(); // Pause the timer if running
    }
}

// Start or continue the timer
function startTimer() {
    if (timerInterval) return;
    isRunning = true;
    timerInterval = setInterval(() => {
        currentTime--;
        if (currentTime <= 0) {
            currentTime = 0;
            clearInterval(timerInterval);
            timerInterval = null;
            isRunning = false;
            handleSessionCompletion();
        }
        updateDisplay();
    }, 1000);
    updateButtonIcon();

    // Dispatch start-task-timer only if currentSession is 'Timer'
    if (currentSession === 'Timer') {
        document.dispatchEvent(new CustomEvent('start-task-timer', { detail: { session: currentSession } }));
    }
}

// Pause the timer
function pauseTimer() {
    clearInterval(timerInterval);
    timerInterval = null;
    isRunning = false;
    updateButtonIcon();

    // Dispatch stop-task-timer only if currentSession is 'Timer'
    if (currentSession === 'Timer') {
        document.dispatchEvent(new Event('stop-task-timer'));
    }
}

// Reset the timer to the start of the current session
function resetTimer() {
    clearInterval(timerInterval);
    timerInterval = null;
    isRunning = false;

    // Reset the main timer's time
    currentTime = currentSession === 'Timer' ? startTime : getBreakDuration();
    updateDisplay();
    updateButtonIcon();

    // Dispatch events to reset task timers
    document.dispatchEvent(new Event('stop-task-timer'));
    document.dispatchEvent(new Event('reset-task-timer'));
}

// Skip to the next session type based on current state
function skipToBreak() {
    console.log(`Skipping to next session from: ${currentSession}`);
    clearInterval(timerInterval); // Stop the interval
    timerInterval = null; // Reset interval reference
    isRunning = false; // Set running state to false

    if (currentSession === 'Timer') {
        handleSessionCompletion(); // Handle session completion if skipping during Timer
    } else {
        startNewTimerSession(); // Start a new Timer session if skipping a break

        // Then optionally auto-start if autoStartAll is true,
        // but not if it's the "first Timer in a cycle."
        if (autoStartAll) {
            const isFirstTimerInCycle = (sessionCount === 1 && currentSession === 'Timer');
            if (!isFirstTimerInCycle) {
                setTimeout(() => {
                    startTimer();
                    updateButtonIcon();
                }, 1500);
            }
        }
    }

    updateDisplay(); // Update the timer display
    updateButtonIcon(); // Update the button icon to reflect state
}

// Handle completion of a session
function handleSessionCompletion() {
    console.log(`Session: ${currentSession}, Time: ${currentTime}, Count: ${sessionCount}`);

    if (currentSession === 'Timer') {
        if (sessionCount < sessionsBeforeLongBreak) {
            sessionCount++; // Increment session count for work sessions
            startShortBreak(); // Start a short break
        } else {
            startLongBreak(); // Start a long break after the set number of sessions
            sessionCount = 1; // Reset session count after long break
        }
    } else {
        startNewTimerSession(); // Start a new work session after a break
    }

    // Determine the next session type
    let nextSessionType = currentSession;
    if (currentSession === 'Timer') {
        nextSessionType = (sessionCount > sessionsBeforeLongBreak) ? 'Long Break' : 'Short Break';
    } else {
        nextSessionType = 'Timer';
    }

    // Function to start the next session after a delay
    const startNextSession = () => {
        if (nextSessionType === 'Timer' && autoStartTimer) {
            startTimer();
        } else if ((nextSessionType === 'Short Break' || nextSessionType === 'Long Break') && autoStartBreaks) {
            startTimer();
        }
    };

    // Decide whether to auto-start the next session based on settings
    // --- new snippet to handle autoStartAll ---
    if (autoStartAll) {
        // figure out the next session type
        /*
        let nextSessionType;
        if (currentSession === 'Timer') {
            // we just ended a Timer
            nextSessionType = (sessionCount > sessionsBeforeLongBreak) ? 'Long Break' : 'Short Break';
        } else {
            // we ended a break
            nextSessionType = 'Timer';
        }
        */

        // we do NOT autostart if the next session is the "first Timer in a new cycle"
        // that means (nextSessionType === 'Timer' && sessionCount === 1)
        const nextSessionIsLongBreak = (nextSessionType === 'Long Break');
        const isFirstTimerInCycle = (nextSessionType === 'Timer' && sessionCount === 1);

        if (nextSessionIsLongBreak) {
            setTimeout(() => {
              startTimer();
              updateButtonIcon();
            }, 1500);
          } else if (!isFirstTimerInCycle) {
            setTimeout(() => {
              startTimer();
              updateButtonIcon();
            }, 1500);
          }
    }
}

// Start a new "Timer" session
function startNewTimerSession() {
    currentSession = 'Timer'; // Set the session type to Timer
    currentTime = startTime; // Reset the timer to the work duration
    updateDisplay(); // Update the timer display
}

// Start a short break session
function startShortBreak() {
    currentSession = 'Short Break'; // Set the session type to Short Break
    currentTime = shortBreakDuration; // Get short break duration from settings or default
    updateDisplay(); // Update the timer display
}

// Start a long break session
function startLongBreak() {
    currentSession = 'Long Break'; // Set the session type to Long Break
    currentTime = longBreakDuration; // Get long break duration from settings or default
    updateDisplay(); // Update the timer display
}

// Update the timer display and title based on current session
function updateDisplay() {
    const minutes = Math.floor(currentTime / 60); // Calculate minutes
    const seconds = currentTime % 60; // Calculate remaining seconds

    // Update the displayed timer
    document.getElementById('timer-display').textContent = 
        `${minutes < 10 ? '0' : ''}${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
    document.getElementById('timer-title').textContent = currentSession; // Update the session title

    // Only update the browser's title if the timer is running
    if (isRunning) {
        document.title = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
    } else {
        document.title = "Study Timer"; // Default title when timer is not running
    }

    // Update session info
    const sessionInfo = document.getElementById('session-info');

    // Correct logic for displaying session count
    if (currentSession === 'Timer') {
        sessionInfo.textContent = `${sessionCount} of ${sessionsBeforeLongBreak} Sessions`;
    } else if (currentSession === 'Short Break') {
        sessionInfo.textContent = `${sessionCount - 1} of ${sessionsBeforeLongBreak} Sessions`;
    } else if (currentSession === 'Long Break') {
        sessionInfo.textContent = `${sessionsBeforeLongBreak} of ${sessionsBeforeLongBreak} Sessions`;
    }
}

// Update the start/pause button icon based on the timer's running state
function updateButtonIcon() {
    const icon = document.getElementById('start-pause-btn').querySelector('i');
    if (isRunning) {
        icon.classList.remove('fa-play'); // Remove play icon
        icon.classList.add('fa-pause'); // Add pause icon
    } else {
        icon.classList.remove('fa-pause'); // Remove pause icon
        icon.classList.add('fa-play'); // Add play icon
    }
}

// Get the appropriate break duration
function getBreakDuration() {
    if (currentSession === 'Short Break') {
        return shortBreakDuration; // Return short break duration in seconds
    } else if (currentSession === 'Long Break') {
        return longBreakDuration; // Return long break duration in seconds
    }
    return startTime; // Return default work duration for Timer session
}

// ------------------------------------------------------------------
// 6) RESPOND TO MAIN TIMER EVENTS (FROM tasks.js)
// ------------------------------------------------------------------
document.addEventListener('start-task-timer', () => {
    // No change needed
    // If a task is active, resume its interval
    if (activeTaskId) {
        startActiveTaskInterval();
    }
});

document.addEventListener('stop-task-timer', () => {
    // No change needed
    // Stop counting time on the active task
    stopActiveTaskInterval();

    // If there's an active task, update the DB with the new timeSpent
    if (activeTaskId) {
        // 1) old total from DB
        const oldDB = dbTimeSpent[activeTaskId] || 0;
        // 2) localTime from this session
        const local = localTime[activeTaskId] || 0;
        // 3) new total = old + local
        const newTotal = oldDB + local;

        fetch(`/tasks/${activeTaskId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ timeSpent: newTotal })
        })
        .then(res => {
            if (!res.ok) throw new Error('Failed to update timeSpent');
            return res.json();
        })
        .then(data => {
            console.log('Updated timeSpent in DB:', data.task.timeSpent);
            updateTaskTotalTime(data.task._id, data.task.timeSpent);
        })
        .catch(err => console.error(err));
    }
});

// Reset task timer
document.addEventListener('reset-task-timer', () => {
    // No change needed
    mainTimerRunning = false;
    stopActiveTaskInterval();

    if (activeTaskId) {
        // Reset the local time to 0
        taskTimes[activeTaskId] = 0;

        // Update the local DOM display
        const activeTask = document.querySelector(`[data-task-id="${activeTaskId}"]`);
        if (activeTask) {
            activeTask.querySelector('.task-local-time').textContent = '0m0s';
        }

        // **NEW**: PUT request to reset timeSpent on the server
        /*
        fetch(`/tasks/${activeTaskId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ timeSpent: 0 })
        })
        .then(res => {
            if (!res.ok) {
                throw new Error('Failed to reset timeSpent in DB');
            }
            return res.json();
        })
        .then(data => {
            console.log('Successfully reset task on server:', data.task);
        })
        .catch(err => {
            console.error(err);
        });
        */
    }
});

// This calls your existing POST /tasks logic:
  fetch('/tasks', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ title: taskName })
  })
  .then(res => {
    if (!res.ok) throw new Error('Failed to create task');
    return res.json();
  })
  .then(data => {
    console.log('Created task:', data.task);
    renderTask(data.task);
    newTaskInput.value = '';
    addTaskPopup.classList.add('hidden');
  })
  .catch(err => {
    console.error(err);
    alert('Error creating task');
  });


------------------------------------------------------------------
function renderTask(task) {
    // Create outer container
    const taskItem = document.createElement('div');
    // Some Tailwind classes for styling:
    taskItem.className = `
      task-item bg-white p-4 rounded-lg shadow-md flex justify-between items-center 
      cursor-pointer relative
    `;
    // We store the MongoDB _id
    // Determine the task ID based on its origin
    const taskId = isServerTask ? task._id : task.id;
    taskItem.setAttribute('data-task-id', taskId);
  
    // Initialize DB vs. local time
    dbTimeSpent[task._id] = task.timeSpent || 0;
    localTime[task._id]    = 0;
  
    // Convert total timeSpent to minutes/seconds for display
    const dbMin = Math.floor(task.timeSpent / 60);
    const dbSec = task.timeSpent % 60;
  
    // We'll build the inner HTML:
    // Left side: check icon + task name
    // Right side: local time + total time + 3-dots
    taskItem.innerHTML = `
      <div class="flex items-center">
        <!-- A “check-circle” icon, can be replaced with your own logic -->
        <i class="fas fa-check-circle text-gray-400"></i>
        <!-- If name is too long, we can add .truncate or a max-width style -->
        <span class="ml-2 text-gray-700 font-semibold task-name" 
              style="max-width:100px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">
          ${task.title}
        </span>
      </div>
      <div class="flex items-center space-x-3">
        <span class="task-local-time text-blue-600 text-sm">Local: 0m0s</span>
        <span class="task-total-time text-gray-500 text-sm">
          Total: ${dbMin}m${dbSec}s
        </span>
        <!-- 3-dots menu trigger -->
        <i class="fas fa-ellipsis-v text-gray-400 cursor-pointer three-dots-menu"></i>
      </div>
    `;
  
    // Append to the #task-list
    taskList.appendChild(taskItem);
  
    // *** (1) Click to toggle selection/unselection
    taskItem.addEventListener('click', (e) => {
      // If the user clicked the 3-dots icon, we don't want to toggle select
      if (e.target.classList.contains('three-dots-menu')) {
        return; 
      }
      if (activeTaskId === task._id) {
        // if it's currently active, unselect
        handleUnselectTask(task._id);
      } else {
        handleSelectTask(task._id);
      }
    });
  
    // *** (2) 3-dots menu: create a small popup or dropdown
    const threeDotsIcon = taskItem.querySelector('.three-dots-menu');
    threeDotsIcon.addEventListener('click', (e) => {
      e.stopPropagation(); // so it doesn't toggle selection
  
      // Build a simple menu
      const menu = document.createElement('div');
      menu.className = `
        absolute top-10 right-4 bg-white border border-gray-300 
        rounded shadow-md text-sm z-10 p-2
      `;
      
      // Common actions
      const deleteLocal = document.createElement('div');
      deleteLocal.textContent = 'Delete locally';
      deleteLocal.className = 'cursor-pointer hover:bg-gray-100 px-2 py-1';
      deleteLocal.addEventListener('click', (ev) => {
        ev.stopPropagation();
        // do your local delete fetch -> then remove from DOM
        fetch(`/tasks/${task._id}`, { method: 'DELETE' })
          .then(res => {
            if(!res.ok) throw new Error('Failed to delete');
            taskItem.remove();
            if (activeTaskId === task._id) {
              activeTaskId = null;
              stopActiveTaskInterval();
            }
          })
          .catch(console.error);
        menu.remove();
      });
      menu.appendChild(deleteLocal);
  
      if (task.todoistId) {
        // *** It's a Todoist task => "Complete" and "Delete from Todoist"
        const complete = document.createElement('div');
        complete.textContent = 'Mark as completed';
        complete.className = 'cursor-pointer hover:bg-gray-100 px-2 py-1';
        complete.addEventListener('click', (ev) => {
          ev.stopPropagation();
          fetch('/todoist/complete', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ taskId: task.todoistId })
          })
          .then(res => {
            if(!res.ok) throw new Error('Failed to complete in Todoist');
            // remove from UI or visually mark as done
            taskItem.remove();
          })
          .catch(console.error);
          menu.remove();
        });
        menu.appendChild(complete);
  
        const deleteTodoist = document.createElement('div');
        deleteTodoist.textContent = 'Delete from Todoist';
        deleteTodoist.className = 'cursor-pointer hover:bg-gray-100 px-2 py-1';
        deleteTodoist.addEventListener('click', (ev) => {
          ev.stopPropagation();
          if(!confirm('Delete from Todoist?')) return;
          fetch('/todoist/delete', {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ taskId: task.todoistId })
          })
          .then(res => {
            if(!res.ok) throw new Error('Failed to delete from Todoist');
            taskItem.remove();
          })
          .catch(console.error);
          menu.remove();
        });
        menu.appendChild(deleteTodoist);
      } else {
        // *** Non‐Todoist => rename option
        const rename = document.createElement('div');
        rename.textContent = 'Rename';
        rename.className = 'cursor-pointer hover:bg-gray-100 px-2 py-1';
        rename.addEventListener('click', (ev) => {
          ev.stopPropagation();
          const newName = prompt('Enter new task name:', task.title);
          if(newName && newName.trim() !== '') {
            fetch(`/tasks/${task._id}`, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ title: newName.trim() })
            })
            .then(res => {
              if(!res.ok) throw new Error('Failed to rename task');
              return res.json();
            })
            .then(updated => {
              // Update UI
              taskItem.querySelector('.task-name').textContent = updated.task.title;
            })
            .catch(console.error);
          }
          menu.remove();
        });
        menu.appendChild(rename);
      }
  
      // Attach to the DOM
      taskItem.appendChild(menu);
  
      // If user clicks outside, remove the menu
      document.addEventListener('click', function docListener() {
        menu.remove();
        document.removeEventListener('click', docListener);
      }, { once: true });
    });
  }


<header>
        <nav>
            <ul>
                <li><a href="index.html">Timer</a></li>
                <li><a href="stats.html">Stats</a></li>
                <li><a href="settings.html">Settings</a></li>
            </ul>
            <div id="login-box">
                <a href="login.html" id="login-link" aria-label="Login">Log in</a>
            </div>
        </nav>
    </header>

<header>
        <nav>
            <ul>
                <li><a href="index.html">Timer</a></li>
                <li><a href="stats.html">Stats</a></li>
                <li><a href="settings.html">Settings</a></li>
            </ul>
            <div id="login-box">
                <a href="login.html" id="login-link" aria-label="Login">Log in</a>
            </div>
        </nav>
    </header>

<div id="todoist-task-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Choose Tasks To Import</h3>
                <button id="close-modal-btn" class="close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <div id="todoist-task-list" class="task-list">
                    <!-- Task items will be dynamically populated here -->
                </div>
            </div>
            <div class="modal-footer">
                <button id="confirm-import-btn" class="primary-btn">Import Selected</button>
            </div>
        </div>
        </div>

<header class="bg-gray-800 py-4 shadow">
        <div class="container mx-auto flex items-center justify-between px-4">
        <!-- Left side: App name -->
        <h1 class="text-2xl font-bold">Focus Flow</h1>
    
        <!-- Right side: Buttons for Stats, Settings, Login/Logout -->
        <div id="login-box" class="flex space-x-4"> </div>
            <button id="stats-btn" class="px-3 py-2 bg-gray-700 rounded hover:bg-gray-600">
            Stats
            </button>
            <button id="settings-btn" class="px-3 py-2 bg-gray-700 rounded hover:bg-gray-600">
            Settings
            </button>
            <a id="login-link" href="login.html" 
            class="px-3 py-2 bg-blue-500 hover:bg-blue-600 rounded">
            Login
            </a>
        </div>
    </header>


// public/js/auth.js

document.addEventListener("DOMContentLoaded", async () => {
  const loginLink = document.getElementById("login-link");
  const logoutButton = document.createElement("button");

  // Style and configure the logout button
  logoutButton.textContent = "Log Out";
  logoutButton.style = `
      display: none; 
      padding: 10px 20px; 
      border: none; 
      background: #dc3545; 
      color: white; 
      cursor: pointer; 
      border-radius: 5px;
      font-size: 16px;
  `;
  logoutButton.id = "logout-button";
  logoutButton.addEventListener("click", showLogoutConfirmationModal);

  // Append the logout button next to the login link
  const loginBox = document.getElementById("login-box");
  loginBox.appendChild(logoutButton);

  try {
      // Fetch login status from the server
      const response = await fetch('/check-session');
      const data = await response.json();

      if (data.loggedIn) {
          // User is logged in
          loginLink.style.display = "none";
          logoutButton.style.display = "inline-block";
      } else {
          // User is not logged in
          loginLink.style.display = "inline-block";
          logoutButton.style.display = "none";
      }
  } catch (error) {
      console.error('Error checking login status:', error);
      loginLink.style.display = "inline-block";
      logoutButton.style.display = "none";
  }

  // Check if a logout just occurred to display the success popup
  if (sessionStorage.getItem('logout') === 'success') {
      showLogoutSuccessPopup();
      sessionStorage.removeItem('logout');
  }
});

// Function to show a logout confirmation modal
function showLogoutConfirmationModal() {
  // Create modal overlay
  const modal = document.createElement("div");
  modal.id = "logout-modal";
  modal.style = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
  `;

  // Create modal content container
  const popup = document.createElement("div");
  popup.style = `
      padding: 30px;
      background: #fff;Flo
      border-radius: 10px;
      text-align: center;
      width: 300px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
  `;

  // Confirmation message
  const message = document.createElement("p");
  message.textContent = "Are you sure you want to log out?";
  message.style = "margin-bottom: 20px; font-size: 18px;";

  // Sign Out button
  const signOutButton = document.createElement("button");
  signOutButton.textContent = "Sign Out";
  signOutButton.style = `
      padding: 10px 20px;
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      margin-right: 10px;
  `;
  /*
  signOutButton.addEventListener("click", async () => {
      try {
          signOutButton.textContent = "Signing out...";
          signOutButton.disabled = true;
          const response = await fetch('/logout', { method: 'POST' }); // Changed to POST for security
          if (response.ok) {
              sessionStorage.setItem('logout', 'success');
              window.location.href = 'index.html'; // Redirect to index.html
          } else {
              throw new Error('Logout failed');
          }
      } catch (error) {
          console.error('Error logging out:', error.message);
          alert('Logout failed. Please try again.');
      }
  });
  */

  signOutButton.addEventListener("click", async () => {
    try {
      signOutButton.textContent = "Signing out...";
      signOutButton.disabled = true;
      
      const response = await fetch('/logout', { method: 'POST' }); // Ensure method is POST
      if (response.ok) {
        sessionStorage.setItem('logout', 'success');
        window.location.href = 'index.html'; // Redirect to index.html
      } else {
        throw new Error('Logout failed');
      }
    } catch (error) {
      console.error('Error logging out:', error.message);
      alert('Logout failed. Please try again.');
      signOutButton.textContent = "Sign Out"; // Reset button text
      signOutButton.disabled = false; // Re-enable the button
    }
  });

  // Cancel button
  const cancelButton = document.createElement("button");
  cancelButton.textContent = "Cancel";
  cancelButton.style = `
      padding: 10px 20px;
      background: #6c757d;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
  `;
  cancelButton.addEventListener("click", () => {
      modal.remove();
  });

  // Assemble modal content
  popup.appendChild(message);
  popup.appendChild(signOutButton);
  popup.appendChild(cancelButton);
  modal.appendChild(popup);
  document.body.appendChild(modal);

  // Close modal when clicking outside the popup
  modal.addEventListener("click", (e) => {
      if (e.target === modal) {
          modal.remove();
      }
  });
}

// Function to show a custom logout success popup
function showLogoutSuccessPopup() {
  const popup = document.createElement("div");
  popup.id = "logout-success-popup";
  popup.style = `
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 15px 25px;
      background: #28a745;
      color: white;
      border-radius: 5px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      z-index: 1001;
      opacity: 0;
      transition: opacity 0.5s ease;
      font-size: 16px;
  `;
  popup.textContent = "You have logged out successfully.";
  document.body.appendChild(popup);
  
  // Fade-in effect
  setTimeout(() => {
      popup.style.opacity = "1";
  }, 100);
  
  // Remove after 3 seconds with fade-out effect
  setTimeout(() => {
      popup.style.opacity = "0";
      setTimeout(() => {
          popup.remove();
      }, 500);
  }, 3000);
}

/* Apply the same background color to all pages */
body {
    background-color: #1a202c; /* Dark gray (matches bg-gray-900) */
    color: #fff; /* White text */
}

<!-- Remaining time circle (Orange) -->
            <circle id="remaining-circle" 
                    cx="50" cy="50" r="45" 
                    stroke="#7C3AED" stroke-width="10"
                    fill="none"
                    stroke-dasharray="282.743" 
                    stroke-dashoffset="282.743" 
                    stroke-linecap="round" 
                    transform="rotate(-90 50 50)"/>


// On page load, fetch tasks from server
// On page load, fetch tasks from server
fetch('/tasks', {
    method: 'GET',
    headers: {
    'Content-Type': 'application/json'
    }
})
.then(res => {
    if (!res.ok) {
    // If user not authenticated or error
    throw new Error('Failed to fetch tasks');
    }
    return res.json();
})
.then(tasks => {
    console.log('Tasks from server:', tasks);
    // Render each task into the DOM
    tasks.forEach(task => {
    renderTask(task);
    });
})
.catch(err => console.error(err)); 

<script src="session.js"></script>


const message = await response.text();
            alert(message);